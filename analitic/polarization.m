% %%
% n=[5 5 4]; % размер решётки (n-1)
% global A G d % константы
% d=10^(-8); % шаг решётки
% A=[-3.712*10^(7) 6.079*10^(8) 1.303*10^(8) 1.294*10^(9) -1.950*10^(9) -2.5*10^(9) 3.863*10^(10) 2.529*10^(-10) 1.637*10^(-10) 1.367*10^(-10)]; % порядки!
% G=[51 0 2]*10^(-11);
% P=cell(3,1);
% [x,y,z]=ndgrid(d*(0:n(1)),d*(0:n(2)),d*(0:n(3))); X={x;y;z}; clear x y z
% P=cell(3,1);
% for i=1:3, P{i}=zeros(size(X{1})); end
% for i=1:3, P{i} = ones(size(X{1})).*0.1685; end
% disp([1, 1, 1])
% energies(P)
% for i=1:3, P{i}=zeros(size(X{1})); end
% for i=1:2, P{i} = ones(size(X{1})).*0.1685; end
% disp([1, 1, 0])
% energies(P)
% for i=1:3, P{i}=zeros(size(X{1})); end
% for i=1:1, P{i} = ones(size(X{1})).*0.1685; end
% disp([1, 0, 0])
% energies(P)


%%
function [X,U,P]=polarization
N=3000;
% data = zeros(idivide(int16(N),int16(100)), 2);
data = [];

n=[10 10 5]; % размер решётки (n-1)
global A G d % константы
d=10^(-8); % шаг решётки
A=[-3.712*10^(7) 6.079*10^(8) 1.303*10^(8) 1.294*10^(9) -1.950*10^(9) -2.5*10^(9) 3.863*10^(10) 2.529*10^(-10) 1.637*10^(-10) 1.367*10^(-10)]; % порядки!
A=[-3.712*10^(7) 6.079*10^(8) 1.303*10^(8)*20 1.294*10^(9) -1.950*10^(9) -2.5*10^(9) 3.863*10^(10) 2.529*10^(-10) 1.637*10^(-10) 1.367*10^(-10)]; % порядки!

G=[51 0 2]*10^(-11);
% d=1;
% A=[-3.712 6.079 1.303 1.294 -1.950 -2.5 3.863 2.529 1.637 1.367]; % порядки!
% G=[51 0 2];

[x,y,z]=ndgrid(d*(0:n(1)),d*(0:n(2)),d*(0:n(3))); X={x;y;z}; clear x y z
P=cell(3,1);
for i=1:3, P{i}=zeros(size(X{1})); end
% задаём значения P при z=0
global fix
fix=false(size(X{1})); fix(:,:,1)=true;

% Сделаем сдвиг на 0.2 через meshgrid (суммарный сдвиг)

% P{1}(fix) = ones(n(1)+1, n(2)+1)*0.1;
% for i=1:3
%     P{i}(fix) = ones(n(1)+1, n(2)+1)*0.001;
% %     P{i}(fix)=(rand(n(1:2)+1)-1/2)*d; 
% end
% P{1}(fix) = ones(n(1)+1, n(2)+1)*0.1;
% for i=1:3
%     P{i} = ones(n+1)*0.1;
% end
P{1} = ones(n+1)*0.1;
% цикл градиентного спуска
F=energies(P); 
k0=0; 
oo=0;
% while true
for i =1:N
        oo=oo+1;
        [GP,gmax]=gradflow; % градиенты
        if gmax<1e-4*d, break, end % критерий остановки
        mu=min(1,1e-3*d/gmax); f=step_along(P,GP,mu); f_=f;
        k=0;
        % определяем интервал одномерного поиска
        if f>F
            while f>F, f=f_; mu=mu/2; f_=step_along(P,GP,mu); end
            mu=2*mu; k=k+1;
        else       
            while f<=f_, f_=f; mu=2*mu; f=step_along(P,GP,mu); k=k+1; end
        end
        if k>k0,k0=k; end
        % вязкость
        mu = mu*0.2;
%         if f-2*f_+F == 0
%             disp([f f_ F])
%             break
%         end
%         mu=mu/4*(1-2*(f_-F)/(f-2*f_+F));
        [F,P]=step_along(P,GP,mu);
        if mod(oo,100)==0 
            data(idivide(int16(oo),int16(100)), 1) = oo;
            data(idivide(int16(oo),int16(100)), 2) = F;
            
        end
%         mu
        F
        oo
%         P{1}
        visual(X, P)
        
end
P{1}
% P{2}
% P{3}
% [F, FL, FG] = energies_arr(P);
% F
% FL
% FG
[F,FL,FG]=energies(P)
% save('data_polarization.mat','data', 'X', 'P')
visual(X,P)
disp([oo k0])

end

%% ========================================================================
function [F,P]=step_along(P,GP,mu)
% энергия после шага в направлении антиградиента: U -> (U - mu*dU)
for i=1:3, P{i}=P{i}-mu*GP{i}; end
F=energies(P);
end

%% ========================================================================
function [F,FL,FG]=energies_arr(P0)
% вычисление энергии и её составляющих
global A G d P dP
% считаем производные на решётке и деформации
dP=derivatives(P0); P=P0;
i1=[1 5 9 6 3 2]; i2=[1 5 9 8 7 4]; % для нумерации по Фойгту
% квадраты и 4-е степени для ускорения счёта
q12=P{1}.^2; q22=P{2}.^2; q32=P{3}.^2; q14=q12.^2; q24=q22.^2; q34=q32.^2;
FL=A(1)*(q12+q22+q32)...
    +A(2)*(q14+q24+q34)...
    +A(3)*(q12.*q22+q22.*q32+q12.*q32)...
    +A(4)*(q12.*q14+q22.*q24+q32.*q34)...
    +A(5)*(q14.*(q22+q32)+q24.*(q12+q32)+q34.*(q12+q22))...
    +A(6)*q12.*q22.*q32...
    +A(7)*(q14.^2+q24.^2+q34.^2)...
    +A(8)*(q12.*q14.*(q22+q32)+q22.*q24.*(q12+q32)+q32.*q34.*(q12+q32))...
    +A(9)*(q14.*q24+q24.*q34+q14.*q34)...
    +A(10)*(q14.*q22.*q32+q24.*q12.*q32+q34.*q12.*q22);
FG=G(1)/2*(dP{1,1}.^2+dP{2,2}.^2+dP{3,3}.^2)...
    +G(2)*(dP{1,1}.*dP{2,2}+dP{2,2}.*dP{3,3}+dP{1,1}.*dP{3,3})...
    +G(3)/2*(dP{1,2}.^2+dP{2,1}.^2+dP{2,3}.^2+dP{3,2}.^2+dP{3,1}.^2+dP{1,3}.^2);
% FL=sum(FL(:));
% F=FL; % * d^3 ?
F=FL+FG; % * d^3 ?
F=F/numel(P0);
end
%% ========================================================================
function [F,FL,FG]=energies(P0)
% вычисление энергии и её составляющих
global A G d P dP
% считаем производные на решётке и деформации
dP=derivatives(P0); P=P0;
i1=[1 5 9 6 3 2]; i2=[1 5 9 8 7 4]; % для нумерации по Фойгту
% квадраты и 4-е степени для ускорения счёта
q12=P{1}.^2; q22=P{2}.^2; q32=P{3}.^2; q14=q12.^2; q24=q22.^2; q34=q32.^2;
FL=A(1)*(q12+q22+q32)...
    +A(2)*(q14+q24+q34)...
    +A(3)*(q12.*q22+q22.*q32+q12.*q32)...
    +A(4)*(q12.*q14+q22.*q24+q32.*q34)...
    +A(5)*(q14.*(q22+q32)+q24.*(q12+q32)+q34.*(q12+q22))...
    +A(6)*q12.*q22.*q32...
    +A(7)*(q14.^2+q24.^2+q34.^2)...
    +A(8)*(q12.*q14.*(q22+q32)+q22.*q24.*(q12+q32)+q32.*q34.*(q12+q32))...
    +A(9)*(q14.*q24+q24.*q34+q14.*q34)...
    +A(10)*(q14.*q22.*q32+q24.*q12.*q32+q34.*q12.*q22);
FG=G(1)/2*(dP{1,1}.^2+dP{2,2}.^2+dP{3,3}.^2)...
    +G(2)*(dP{1,1}.*dP{2,2}+dP{2,2}.*dP{3,3}+dP{1,1}.*dP{3,3})...
    +G(3)/2*(dP{1,2}.^2+dP{2,1}.^2+dP{2,3}.^2+dP{3,2}.^2+dP{3,1}.^2+dP{1,3}.^2);
% FL=sum(FL(:));
% F=FL; % * d^3 ?
FL=sum(FL(:)); FG=sum(FG(:));
F=FL+FG; % * d^3 ?
F=F/numel(P0{1});
end

%% ========================================================================
function D=derivatives(V)
% вычисляем производные векторного поля на решётке: внутренние узлы по
% формулам 2-го порядка, граничные - по формулам 1-го порядка
% компоненты поля V - массив cell(3,1)
global d
D=cell(3,3); for i=1:9, D{i}=zeros(size(V{1})); end
for i=1:3, V{i}=V{i}/d/2; end % сразу учитываем шаг решётки
for i=1:3
    D{i,1}(2:end-1,:,:)=V{i}(3:end,:,:)-V{i}(1:end-2,:,:);
    D{i,1}([1 end],:,:)=2*cat(1,V{i}(2,:,:)-V{i}(1,:,:),V{i}(end,:,:)-V{i}(end-1,:,:));
    D{i,2}(:,2:end-1,:)=V{i}(:,3:end,:)-V{i}(:,1:end-2,:);
    D{i,2}(:,[1 end],:)=2*cat(2,V{i}(:,2,:)-V{i}(:,1,:),V{i}(:,end,:)-V{i}(:,end-1,:));
    D{i,3}(:,:,2:end-1)=V{i}(:,:,3:end)-V{i}(:,:,1:end-2);
    D{i,3}(:,:,[1 end])=2*cat(3,V{i}(:,:,2)-V{i}(:,:,1),V{i}(:,:,end)-V{i}(:,:,end-1));
end
end

%% ========================================================================
function [GP,gmax]=gradflow
% вычисляем градиент - производные энергии по (P1,P2,P3) и (U1,U2,U3) каждого узла
global A C Q G d E P dP fix
GP=cell(3,1);
% вспомогательные переменные для ускорения счёта
q2=cell(3,1); q4=q2; q6=q2; PP=q2; P2=0; P4=0; P6=0;
for i=1:3
    q2{i}=P{i}.^2; q4{i}=q2{i}.^2; q6{i}=q2{i}.^3;
    P2=P2+q2{i}; P4=P4+q4{i}; P6=P6+q6{i};
end
PP{1}=q2{2}.*q2{3}; PP{2}=q2{1}.*q2{3}; PP{3}=q2{1}.*q2{2};
% локальная часть
for i=1:3
    % производная энергии Ландау
    GP{i}=A(1)+2*A(2)*q2{i}+A(3)*(P2-q2{i})+3*A(4)*q4{i}...
        +A(5)*(2*q2{i}.*(P2-q2{i})+(P4-q4{i}))+A(6)*PP{i}+4*A(7)*q6{i}...
        +A(8)*(3*q4{i}.*(P2-q2{i})+P6-q6{i})+2*A(9)*q2{i}.*(P4-q4{i})...
        +A(10)*PP{i}.*(q2{i}+P2);
    GP{i}=2*P{i}.*GP{i};
end
% нелокальная часть
g=G/2/d; % если нужны конечные разности, то не делить на d!
for i=1:3
    per=[i:3 1:i-1]; % перестановка размерностей
    i1=per(1); i2=per(2); i3=per(3);
    % производные по компонентам вектора P
    % производные "вдоль", типа P1,1
    T=g(1)*dP{i1,i1}+g(2)*(dP{i2,i2}+dP{i3,i3});
    GP{i1}=GP{i1}+gradflow_local(T,i1);
    % производные "поперёк", типа P1,2 и P1,3
    T=g(3)*dP{i1,i2};
    GP{i1}=GP{i1}+gradflow_local(T,i2);
    T=g(3)*dP{i1,i3};
    GP{i1}=GP{i1}+gradflow_local(T,i3);
    % GP{i1}(fix)=0; % для фиксированных узлов
end
% максимальная длина градиента P
gmax=sqrt(max(GP{1}(:).^2+GP{2}(:).^2+GP{3}(:).^2));
end
%% ========================================================================
function D=gradflow_local(T,dim)
% преобразование массива в разностный вдоль размерности dim 
% (вспомог. функция для gradflow)
D=zeros(size(T)); Z=false(size(T));
n=size(T); ind={1:n(1) 1:n(2) 1:n(3)};
% внутренние слои
ind{dim}=2:n(dim)-1; Z(ind{:})=true; ind0=Z; Z(:)=false;
ind{dim}=3:n(dim); Z(ind{:})=true; ind1=Z; Z(:)=false;
ind{dim}=1:n(dim)-2; Z(ind{:})=true; ind2=Z; Z(:)=false;
D(ind1)=T(ind0); D(ind2)=D(ind2)-T(ind0);
% граничные и приграничные слои
ind{dim}=[1 n(dim)]; Z(ind{:})=true; ind0=Z; Z(:)=false;
ind{dim}=[2 n(dim)]; Z(ind{:})=true; ind1=Z; Z(:)=false;
ind{dim}=[1 n(dim)-1]; Z(ind{:})=true; ind2=Z;
D(ind1)=D(ind1)+2*T(ind0); D(ind2)=D(ind2)-2*T(ind0);
end

%% ========================================================================
function visual(X,P)
% визуализация решётки с деформациями и поляризацией
dx=zeros(3,1); xmin=dx; X1=X; G=dx; G1=dx;
d=X{1}(2,1,1)-X{1}(1,1,1); % шаг решётки
for i=1:3, xmin(i)=min(X{i}(:)); dx(i)=max(X{i}(:))-xmin(i); end
% строим подложку
patch(xmin(1)+[-1 5 5 -1]/4*dx(1),xmin(2)+[-1 -1 5 5]/4*dx(2),[0 0 0 0],...
    'facecolor',0.9*[1 1 1])
% находим максимальные смещения и поляризации
pmax=P{1}.^2+P{2}.^2+P{3}.^2;
pmax=sqrt(max(pmax(:)));
% нормируем векторные поля с учётом размера ячейки
for i=1:3
    P{i}=(3/4*d/pmax)*P{i}; X1{i}=X{i};
end
% строим исходную и деформированную решётки
for i=1:3
    x=X; x1=X1; per=[i:3 1:i-1];
    for j=1:3
        x{j}=permute(x{j},per); x{j}(end+1,:,:)=NaN;
        x1{j}=permute(x1{j},per); x1{j}(end+1,:,:)=NaN;
    end
    G(i)=line(x{1}(:),x{2}(:),x{3}(:),'color',[1 0 0 0.2],'linewidth',0.1);
    G1(i)=line(x1{1}(:),x1{2}(:),x1{3}(:),'color',[0 0 1 0.5],'linewidth',1);
end
axis equal, hold on
cla
% строим векторы поляризации
for i=1:3, XP{i}=[X1{i}(:) X1{i}(:)+P{i}(:)]'; end
line(XP{1},XP{2},XP{3},'color',[0.9 0.4 0.1],'linewidth',2.5)
scatter3(X1{1}(:),X1{2}(:),X1{3}(:),'MarkerEdgeColor','k',...
    'MarkerFaceColor',[0 .75 .75],'SizeData',5)
axis tight
drawnow
end